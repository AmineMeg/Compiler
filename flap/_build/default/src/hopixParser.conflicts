
** Conflict (shift/reduce) in state 216.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

EXTERN identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty MULT ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
EXTERN identifier COLONLINE tscheme 
                            loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                          (?)

** In state 216, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty MULT ty 
        ty . RARROW ty 

** In state 216, looking ahead at RARROW, reducing production
** ty -> ty MULT ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty MULT ty . 

** Conflict (shift/reduce) in state 214.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

EXTERN identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty RARROW ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
EXTERN identifier COLONLINE tscheme 
                            loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                          (?)

** In state 214, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty RARROW ty 
          ty . RARROW ty 

** In state 214, looking ahead at RARROW, reducing production
** ty -> ty RARROW ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty RARROW ty . 

** Conflict (shift/reduce) in state 171.
** Tokens involved: PLUS DOT
** The following explanations concentrate on token PLUS.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression PLUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 171, looking ahead at PLUS, shifting is permitted
** because of the following sub-derivation:

expression PLUS expression 
                expression . PLUS expression 

** In state 171, looking ahead at PLUS, reducing production
** expression -> expression PLUS expression
** is permitted because of the following sub-derivation:

expression PLUS expression // lookahead token appears
expression PLUS expression . 

** Conflict (shift/reduce) in state 169.
** Tokens involved: PLUS DOT
** The following explanations concentrate on token PLUS.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS IF expression THEN expression ELSE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 169, looking ahead at PLUS, shifting is permitted
** because of the following sub-derivation:

IF expression THEN expression ELSE expression 
                                   expression . PLUS expression 

** In state 169, looking ahead at PLUS, reducing production
** expression -> IF expression THEN expression ELSE expression
** is permitted because of the following sub-derivation:

expression PLUS expression // lookahead token appears
IF expression THEN expression ELSE expression . 

** Conflict (shift/reduce) in state 118.
** Tokens involved: PLUS DOT
** The following explanations concentrate on token PLUS.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR IF expression THEN expression ELSE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR loption(separated_nonempty_list(COMMA,located(expression))) RPAR 
                                                                        separated_nonempty_list(COMMA,located(expression)) 
                                                                        expression 
                                                                        (?)

** In state 118, looking ahead at PLUS, shifting is permitted
** because of the following sub-derivation:

IF expression THEN expression ELSE expression 
                                   expression . PLUS expression 

** In state 118, looking ahead at PLUS, reducing production
** expression -> IF expression THEN expression ELSE expression
** is permitted because of the following sub-derivation:

expression PLUS expression // lookahead token appears
IF expression THEN expression ELSE expression . 

** Conflict (shift/reduce) in state 101.
** Tokens involved: PLUS DOT
** The following explanations concentrate on token PLUS.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR expression PLUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR loption(separated_nonempty_list(COMMA,located(expression))) RPAR 
                                                                        separated_nonempty_list(COMMA,located(expression)) 
                                                                        expression 
                                                                        (?)

** In state 101, looking ahead at PLUS, shifting is permitted
** because of the following sub-derivation:

expression PLUS expression 
                expression . PLUS expression 

** In state 101, looking ahead at PLUS, reducing production
** expression -> expression PLUS expression
** is permitted because of the following sub-derivation:

expression PLUS expression // lookahead token appears
expression PLUS expression . 

** Conflict (shift/reduce) in state 28.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

LET identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty MULT ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
               COLONLINE tscheme 
                         loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                       (?)

** In state 28, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty MULT ty 
        ty . RARROW ty 

** In state 28, looking ahead at RARROW, reducing production
** ty -> ty MULT ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty MULT ty . 

** Conflict (shift/reduce) in state 26.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

LET identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty RARROW ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
               COLONLINE tscheme 
                         loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                       (?)

** In state 26, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty RARROW ty 
          ty . RARROW ty 

** In state 26, looking ahead at RARROW, reducing production
** ty -> ty RARROW ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty RARROW ty . 

** Conflict (reduce/reduce) in state 13.
** Tokens involved: error TYPE LET FUN EXTERN EOF
** The following explanations concentrate on token error.
** This state is reached from program after reading:

TYPE typecons loption(delimited(INF,separated_nonempty_list(COMMA,located(typevar)),SUP)) EQUALS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) // lookahead token appears because list(located(def)) can begin with error
TYPE typecons loption(delimited(INF,separated_nonempty_list(COMMA,located(typevar)),SUP)) EQUALS tdef // lookahead token is inherited
                                                                                                 (?)

** In state 13, looking ahead at error, reducing production
** loption(delimited(LBRACK,separated_nonempty_list(COMMA,separated_pair(located(label),COLONLINE,located(ty))),RBRACK)) ->
** is permitted because of the following sub-derivation:

loption(delimited(LBRACK,separated_nonempty_list(COMMA,separated_pair(located(label),COLONLINE,located(ty))),RBRACK)) // lookahead token is inherited
. 

** In state 13, looking ahead at error, reducing production
** option(PIPE) ->
** is permitted because of the following sub-derivation:

option(PIPE) loption(separated_nonempty_list(PIPE,pair(located(constructor),loption(delimited(LPAR,separated_nonempty_list(COMMA,located(ty)),RPAR))))) // lookahead token is inherited because loption(separated_nonempty_list(PIPE,pair(located(constructor),loption(delimited(LPAR,separated_nonempty_list(COMMA,located(ty)),RPAR))))) can vanish
. 
