
** Conflict (shift/reduce) in state 329.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

EXTERN identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty MULT ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
EXTERN identifier COLONLINE tscheme 
                            loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                          (?)

** In state 329, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty MULT ty 
        ty . RARROW ty 

** In state 329, looking ahead at RARROW, reducing production
** ty -> ty MULT ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty MULT ty . 

** Conflict (shift/reduce) in state 327.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

EXTERN identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty RARROW ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
EXTERN identifier COLONLINE tscheme 
                            loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                          (?)

** In state 327, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty RARROW ty 
          ty . RARROW ty 

** In state 327, looking ahead at RARROW, reducing production
** ty -> ty RARROW ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty RARROW ty . 

** Conflict (shift/reduce) in state 308.
** Tokens involved: LET FUN
** The following explanations concentrate on token LET.
** This state is reached from program after reading:

FUN identifier option(preceded(COLONLINE,located(tscheme))) pattern EQUALS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
(?)

** In state 308, looking ahead at LET, reducing production
** fundef -> pattern EQUALS expression
** is permitted because of the following sub-derivation:

def list(located(def)) // lookahead token appears because list(located(def)) can begin with LET
vdef // lookahead token is inherited
FUN separated_nonempty_list(AND,fundef_aux) // lookahead token is inherited
    fundef_aux // lookahead token is inherited
    identifier option(preceded(COLONLINE,located(tscheme))) fundef // lookahead token is inherited
                                                            pattern EQUALS expression . 

** In state 308, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

def list(located(def)) 
vdef 
FUN separated_nonempty_list(AND,fundef_aux) 
    fundef_aux 
    identifier option(preceded(COLONLINE,located(tscheme))) fundef 
                                                            pattern EQUALS expression 
                                                                           expression expression 
                                                                                      vdef SEMICOLON expression 
                                                                                      . LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 

** Conflict (shift/reduce) in state 301.
** Tokens involved: LET FUN
** The following explanations concentrate on token LET.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
(?)

** In state 301, looking ahead at LET, shifting is permitted
** because of the following sub-derivation:

def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   expression expression 
                                                                              vdef SEMICOLON expression 
                                                                              . LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 

** In state 301, looking ahead at LET, reducing production
** vdef -> LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression
** is permitted because of the following sub-derivation:

def list(located(def)) // lookahead token appears because list(located(def)) can begin with LET
vdef // lookahead token is inherited
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression . 

** Conflict (shift/reduce) in state 300.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS REF expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 300, looking ahead at WHILE, reducing production
** expression -> REF expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
REF expression . 

** In state 300, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

REF expression 
    expression expression 
               . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 299.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS EDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 299, looking ahead at WHILE, reducing production
** expression -> EDOT expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
EDOT expression . 

** In state 299, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

EDOT expression 
     expression expression 
                . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 298.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS ANSLASH pattern RARROW expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 298, looking ahead at WHILE, reducing production
** expression -> ANSLASH pattern RARROW expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
ANSLASH pattern RARROW expression . 

** In state 298, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

ANSLASH pattern RARROW expression 
                       expression expression 
                                  . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 293.
** Token involved: LPAR
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP))

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 293, looking ahead at LPAR, reducing production
** loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) ->
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with LPAR
constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP)) loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) // lookahead token is inherited
                                                                         . 

** In state 293, looking ahead at LPAR, shifting is permitted
** because of the following sub-derivation:

constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP)) loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) 
                                                                         . LPAR loption(separated_nonempty_list(COMMA,located(expression))) RPAR 

** Conflict (shift/reduce) in state 291.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 291, looking ahead at WHILE, reducing production
** expression -> expression expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
expression expression . 

** In state 291, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

expression expression 
           expression expression 
                      . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 287.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression DOUBLEDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 287, looking ahead at WHILE, reducing production
** expression -> expression DOUBLEDOTEQ expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
expression DOUBLEDOTEQ expression . 

** In state 287, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

expression DOUBLEDOTEQ expression 
                       expression expression 
                                  . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 285.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS vdef SEMICOLON expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 285, looking ahead at WHILE, reducing production
** expression -> vdef SEMICOLON expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
vdef SEMICOLON expression . 

** In state 285, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

vdef SEMICOLON expression 
               expression expression 
                          . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 236.
** Token involved: RPAR
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   (?)

** In state 236, looking ahead at RPAR, shifting is permitted
** because of the following sub-derivation:

LPAR expression . RPAR 

** In state 236, looking ahead at RPAR, reducing production
** separated_nonempty_list(COMMA,located(expression)) -> expression
** is permitted because of the following sub-derivation:

LPAR separated_nonempty_list(COMMA,located(expression)) RPAR // lookahead token appears
     expression . 

** Conflict (shift/reduce) in state 200.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR REF expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 200, looking ahead at WHILE, reducing production
** expression -> REF expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
REF expression . 

** In state 200, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

REF expression 
    expression expression 
               . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 195.
** Token involved: RPAR
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR LPAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 195, looking ahead at RPAR, shifting is permitted
** because of the following sub-derivation:

LPAR expression . RPAR 

** In state 195, looking ahead at RPAR, reducing production
** separated_nonempty_list(COMMA,located(expression)) -> expression
** is permitted because of the following sub-derivation:

LPAR separated_nonempty_list(COMMA,located(expression)) RPAR // lookahead token appears
     expression . 

** Conflict (shift/reduce) in state 164.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR EDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 164, looking ahead at WHILE, reducing production
** expression -> EDOT expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
EDOT expression . 

** In state 164, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

EDOT expression 
     expression expression 
                . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 163.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR ANSLASH pattern RARROW expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 163, looking ahead at WHILE, reducing production
** expression -> ANSLASH pattern RARROW expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
ANSLASH pattern RARROW expression . 

** In state 163, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

ANSLASH pattern RARROW expression 
                       expression expression 
                                  . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 154.
** Token involved: LPAR
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP))

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 154, looking ahead at LPAR, reducing production
** loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) ->
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with LPAR
constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP)) loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) // lookahead token is inherited
                                                                         . 

** In state 154, looking ahead at LPAR, shifting is permitted
** because of the following sub-derivation:

constructor option(delimited(INF,separated_list(COMMA,located(ty)),SUP)) loption(delimited(LPAR,separated_list(COMMA,located(expression)),RPAR)) 
                                                                         . LPAR loption(separated_nonempty_list(COMMA,located(expression))) RPAR 

** Conflict (shift/reduce) in state 152.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR expression expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 152, looking ahead at WHILE, reducing production
** expression -> expression expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
expression expression . 

** In state 152, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

expression expression 
           expression expression 
                      . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 149.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR expression DOUBLEDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 149, looking ahead at WHILE, reducing production
** expression -> expression DOUBLEDOTEQ expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
expression DOUBLEDOTEQ expression . 

** In state 149, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

expression DOUBLEDOTEQ expression 
                       expression expression 
                                  . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 147.
** Tokens involved: WHILE SWITCH STRING REF LPAR LET LBRACK INT IF ID FUN FOR EDOT DOUBLEDOTEQ DOT CID CHAR ANSLASH
** The following explanations concentrate on token WHILE.
** This state is reached from program after reading:

LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS LPAR vdef SEMICOLON expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
                                                                   LPAR expression RPAR 
                                                                        (?)

** In state 147, looking ahead at WHILE, reducing production
** expression -> vdef SEMICOLON expression
** is permitted because of the following sub-derivation:

expression expression // lookahead token appears because expression can begin with WHILE
vdef SEMICOLON expression . 

** In state 147, looking ahead at WHILE, shifting is permitted
** because of the following sub-derivation:

vdef SEMICOLON expression 
               expression expression 
                          . WHILE LPAR expression RPAR LBRACK expression RBRACK 

** Conflict (shift/reduce) in state 29.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

LET identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty MULT ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
               COLONLINE tscheme 
                         loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                       (?)

** In state 29, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty MULT ty 
        ty . RARROW ty 

** In state 29, looking ahead at RARROW, reducing production
** ty -> ty MULT ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty MULT ty . 

** Conflict (shift/reduce) in state 27.
** Tokens involved: RARROW MULT
** The following explanations concentrate on token RARROW.
** This state is reached from program after reading:

LET identifier COLONLINE loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty RARROW ty

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(located(def)) EOF 
def list(located(def)) 
vdef 
LET identifier option(preceded(COLONLINE,located(tscheme))) EQUALS expression 
               COLONLINE tscheme 
                         loption(delimited(LSQR,nonempty_list(located(typevar)),RSQR)) ty 
                                                                                       (?)

** In state 27, looking ahead at RARROW, shifting is permitted
** because of the following sub-derivation:

ty RARROW ty 
          ty . RARROW ty 

** In state 27, looking ahead at RARROW, reducing production
** ty -> ty RARROW ty
** is permitted because of the following sub-derivation:

ty RARROW ty // lookahead token appears
ty RARROW ty . 
